{% extends "base.html" %}

{% block title %}å¯¹è¯ç»ƒä¹  - è‹±è¯­å­¦ä¹ {% endblock %}

{% block head %}
<script src="/static/recorder.js"></script>
{% endblock %}

{% block body %}
<div class="min-h-screen bg-slate-900 flex flex-col" x-data="conversationPage()">
    <!-- é¡¶éƒ¨å¯¼èˆª -->
    <header class="bg-slate-800/80 backdrop-blur-sm shadow-lg border-b border-slate-700/50">
        <div class="max-w-2xl mx-auto px-4 py-3 flex items-center justify-between">
            <button @click="goBack" class="text-slate-400 hover:text-slate-200">
                <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7"></path>
                </svg>
            </button>
            <div class="text-center">
                <span class="font-medium text-slate-100">å¯¹è¯ç»ƒä¹ </span>
                <div class="text-xs text-slate-400">
                    ç¬¬ <span x-text="currentRound"></span> / <span x-text="totalRounds"></span> è½®
                </div>
            </div>
            <!-- éŸ³è‰²é€‰æ‹© -->
            <div class="relative" x-data="{ open: false }">
                <button @click="open = !open" class="text-slate-400 hover:text-slate-200 flex items-center gap-1">
                    <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15.536 8.464a5 5 0 010 7.072M18.364 5.636a9 9 0 010 12.728M5.586 15H4a1 1 0 01-1-1v-4a1 1 0 011-1h1.586l4.707-4.707A1 1 0 0112 5.586v12.828a1 1 0 01-1.707.707L5.586 15z"/>
                    </svg>
                </button>
                <div x-show="open" @click.away="open = false" x-cloak
                     class="absolute right-0 mt-2 w-32 bg-slate-800 border border-slate-700 rounded-lg shadow-xl z-50 py-1">
                    <template x-for="v in TTS.voices" :key="v.id">
                        <button @click="TTS.setVoice(v.id); open = false"
                                :class="TTS.getVoice() === v.id ? 'text-sky-400 bg-slate-700/50' : 'text-slate-300 hover:bg-slate-700/30'"
                                class="w-full text-left px-3 py-1.5 text-sm"
                                x-text="v.label"></button>
                    </template>
                </div>
            </div>
        </div>
    </header>

    <!-- åŠ è½½çŠ¶æ€ -->
    <div x-show="isInitializing" class="flex-1 flex items-center justify-center">
        <div class="text-center">
            <div class="animate-spin rounded-full h-12 w-12 border-b-2 border-sky-500 mx-auto mb-4"></div>
            <p class="text-slate-400">æ­£åœ¨å‡†å¤‡å¯¹è¯...</p>
        </div>
    </div>

    <!-- é”™è¯¯çŠ¶æ€ -->
    <div x-show="initError" class="flex-1 flex items-center justify-center p-4">
        <div class="text-center max-w-sm">
            <div class="text-4xl mb-4">ğŸ˜”</div>
            <p class="text-slate-300 mb-4" x-text="initError"></p>
            <button @click="goBack" class="px-6 py-2 bg-slate-700 text-slate-200 rounded-lg">
                è¿”å›
            </button>
        </div>
    </div>

    <!-- å¯¹è¯ç•Œé¢ -->
    <main x-show="!isInitializing && !initError" x-cloak class="flex-1 flex flex-col max-w-2xl mx-auto w-full p-4">
        <!-- å¯¹è¯å†å² -->
        <div class="flex-1 overflow-y-auto space-y-4 mb-4" x-ref="chatContainer">
            <template x-for="(msg, idx) in messages" :key="idx">
                <div :class="msg.role === 'ai' ? 'flex justify-start' : 'flex justify-end'">
                    <div :class="msg.role === 'ai'
                        ? 'bg-slate-700/50 text-slate-100 rounded-2xl rounded-tl-sm'
                        : 'bg-sky-600 text-white rounded-2xl rounded-tr-sm'"
                        class="max-w-[80%] px-4 py-3">
                        <!-- æ¶ˆæ¯å†…å®¹ï¼Œæ”¯æŒæ¢è¡Œ -->
                        <div class="whitespace-pre-wrap" x-text="msg.content"></div>
                        <div x-show="msg.chinese" class="text-sm opacity-70 mt-1" x-text="msg.chinese"></div>
                        <!-- æ’­æ”¾æŒ‰é’®ï¼ˆAI æ¶ˆæ¯ï¼‰ -->
                        <button
                            x-show="msg.role === 'ai' && msg.ttsText"
                            @click="playTTS(msg.ttsText)"
                            class="mt-2 text-sky-300 hover:text-sky-200 text-sm flex items-center gap-1"
                        >
                            <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15.536 8.464a5 5 0 010 7.072m2.828-9.9a9 9 0 010 12.728M5.586 15H4a1 1 0 01-1-1v-4a1 1 0 011-1h1.586l4.707-4.707C10.923 3.663 12 4.109 12 5v14c0 .891-1.077 1.337-1.707.707L5.586 15z"></path>
                            </svg>
                            é‡æ’­
                        </button>
                    </div>
                </div>
            </template>

            <!-- è¯†åˆ«ä¸­æç¤º -->
            <div x-show="isRecognizing" class="flex justify-end">
                <div class="bg-sky-600/50 text-white rounded-2xl rounded-tr-sm px-4 py-3">
                    <span class="animate-pulse">è¯†åˆ«ä¸­...</span>
                </div>
            </div>

            <!-- AI æ€è€ƒä¸­æç¤º -->
            <div x-show="isLoading && !isRecognizing" class="flex justify-start">
                <div class="bg-slate-700/50 text-slate-100 rounded-2xl rounded-tl-sm px-4 py-3">
                    <span class="animate-pulse">AI æ­£åœ¨æ€è€ƒ...</span>
                </div>
            </div>
        </div>

        <!-- ç›®æ ‡å•è¯æç¤º -->
        <div x-show="targetWords.length > 0 && !isComplete" class="mb-4">
            <div class="text-slate-400 text-sm mb-2">è¯•ç€åœ¨å›å¤ä¸­ä½¿ç”¨è¿™äº›å•è¯ï¼š</div>
            <div class="flex flex-wrap gap-2">
                <template x-for="word in targetWords" :key="word">
                    <span class="px-3 py-1 bg-amber-500/20 text-amber-300 rounded-full text-sm"
                          x-text="word"></span>
                </template>
            </div>
        </div>

        <!-- å½•éŸ³æ§åˆ¶åŒº -->
        <div x-show="!isComplete" class="flex flex-col items-center py-6">
            <!-- å½•éŸ³æŒ‰é’® -->
            <button
                @mousedown="startRecording"
                @mouseup="stopRecording"
                @mouseleave="isRecording && stopRecording()"
                @touchstart.prevent="startRecording"
                @touchend.prevent="stopRecording"
                :disabled="isLoading || isRecognizing || !recorderReady"
                :class="isRecording
                    ? 'bg-rose-500 scale-110 shadow-lg shadow-rose-500/50'
                    : 'bg-sky-600 hover:bg-sky-500'"
                class="w-20 h-20 rounded-full flex items-center justify-center transition-all duration-200 disabled:opacity-50 disabled:cursor-not-allowed"
            >
                <svg x-show="!isRecording" class="w-8 h-8 text-white" fill="currentColor" viewBox="0 0 24 24">
                    <path d="M12 14c1.66 0 3-1.34 3-3V5c0-1.66-1.34-3-3-3S9 3.34 9 5v6c0 1.66 1.34 3 3 3z"/>
                    <path d="M17 11c0 2.76-2.24 5-5 5s-5-2.24-5-5H5c0 3.53 2.61 6.43 6 6.92V21h2v-3.08c3.39-.49 6-3.39 6-6.92h-2z"/>
                </svg>
                <div x-show="isRecording" class="w-6 h-6 bg-white rounded-sm"></div>
            </button>
            <p class="text-slate-400 text-sm mt-3">
                <span x-show="!recorderReady">æ­£åœ¨åˆå§‹åŒ–éº¦å…‹é£...</span>
                <span x-show="recorderReady && !isRecording">æŒ‰ä½è¯´è‹±è¯­</span>
                <span x-show="isRecording">æ¾å¼€ç»“æŸå½•éŸ³</span>
            </p>

            <!-- å½•éŸ³æ—¶é•¿ -->
            <div x-show="isRecording" class="mt-2 text-rose-400 text-sm font-mono">
                <span x-text="recordingDuration"></span>
            </div>

            <!-- è¯†åˆ«ç»“æœé¢„è§ˆ -->
            <div x-show="recognizedText && !isLoading" class="mt-4 text-center max-w-xs">
                <p class="text-slate-400 text-sm">ä½ è¯´çš„ï¼š</p>
                <p class="text-slate-100" x-text="recognizedText"></p>
            </div>
        </div>
    </main>

    <!-- å‘éŸ³çº æ­£å¯¹è¯æ¡† -->
    <div x-show="showPronunciationFix" x-cloak
         class="fixed inset-0 bg-black/50 flex items-center justify-center p-4 z-50"
         x-transition:enter="transition ease-out duration-200"
         x-transition:enter-start="opacity-0"
         x-transition:enter-end="opacity-100">
        <div class="bg-slate-800 rounded-2xl p-6 max-w-sm w-full border border-slate-700 transform"
             x-transition:enter="transition ease-out duration-200"
             x-transition:enter-start="scale-95"
             x-transition:enter-end="scale-100">
            <div class="text-3xl text-center mb-3">ğŸ¤</div>
            <h2 class="text-lg font-bold text-slate-100 text-center mb-2">å‘éŸ³ç¡®è®¤</h2>
            <p class="text-slate-400 text-sm text-center mb-4" x-text="pronunciationIssue.reason"></p>

            <div class="bg-slate-700/50 rounded-xl p-4 mb-4">
                <div class="text-slate-400 text-sm mb-2">è¯­éŸ³è¯†åˆ«ç»“æœï¼š</div>
                <div class="text-slate-200 font-medium" x-text="pronunciationIssue.originalText"></div>
            </div>

            <p class="text-slate-300 text-sm text-center mb-4">ä½ æƒ³è¯´çš„æ˜¯å“ªä¸ªè¯ï¼Ÿ</p>

            <div class="space-y-2">
                <!-- ä½¿ç”¨å»ºè®®çš„è¯ -->
                <button @click="useSuggestedWord()"
                        class="w-full py-3 px-4 bg-emerald-600 hover:bg-emerald-500 text-white rounded-xl font-medium transition flex items-center justify-center gap-2">
                    <span>âœ“</span>
                    <span>æˆ‘æƒ³è¯´ "<span x-text="pronunciationIssue.suggestedWord"></span>"</span>
                </button>

                <!-- ä¿æŒåŸæ · -->
                <button @click="keepOriginalWord()"
                        class="w-full py-3 px-4 bg-slate-600 hover:bg-slate-500 text-white rounded-xl font-medium transition flex items-center justify-center gap-2">
                    <span>ä¿æŒåŸæ · "<span x-text="pronunciationIssue.originalWord"></span>"</span>
                </button>
            </div>
        </div>
    </div>

    <!-- å®Œæˆå¼¹çª— -->
    <div x-show="isComplete" x-cloak
         class="fixed inset-0 bg-black/50 flex items-center justify-center p-4 z-50"
         x-transition:enter="transition ease-out duration-300"
         x-transition:enter-start="opacity-0"
         x-transition:enter-end="opacity-100">
        <div class="bg-slate-800 rounded-2xl p-6 max-w-sm w-full border border-slate-700 transform"
             x-transition:enter="transition ease-out duration-300"
             x-transition:enter-start="scale-95"
             x-transition:enter-end="scale-100">
            <div class="text-4xl text-center mb-4">ğŸ‰</div>
            <h2 class="text-xl font-bold text-slate-100 text-center mb-4">å¯¹è¯å®Œæˆ!</h2>
            <div class="space-y-3 mb-6">
                <div class="flex justify-between">
                    <span class="text-slate-400">ç»ƒä¹ å•è¯</span>
                    <span class="text-slate-100" x-text="summary.words_practiced?.length || 0"></span>
                </div>
                <div class="flex justify-between">
                    <span class="text-slate-400">æ­£ç¡®ä½¿ç”¨</span>
                    <span class="text-emerald-400" x-text="summary.words_used_correctly?.length || 0"></span>
                </div>
                <div class="flex justify-between">
                    <span class="text-slate-400">å¾—åˆ†</span>
                    <span class="text-sky-400" x-text="(summary.score || 0) + 'åˆ†'"></span>
                </div>
            </div>
            <!-- ä½¿ç”¨çš„å•è¯åˆ—è¡¨ -->
            <div x-show="summary.words_used_correctly?.length > 0" class="mb-4">
                <p class="text-slate-400 text-sm mb-2">ä½ ä½¿ç”¨çš„å•è¯ï¼š</p>
                <div class="flex flex-wrap gap-1">
                    <template x-for="word in summary.words_used_correctly" :key="word">
                        <span class="px-2 py-1 bg-emerald-500/20 text-emerald-300 rounded text-xs" x-text="word"></span>
                    </template>
                </div>
            </div>
            <p class="text-slate-300 text-sm text-center mb-6" x-text="summary.overall_feedback"></p>
            <button @click="goBack" class="w-full py-3 bg-gradient-to-r from-sky-500 to-blue-500 text-white rounded-xl font-medium hover:from-sky-600 hover:to-blue-600 transition">
                è¿”å›é¦–é¡µ
            </button>
        </div>
    </div>
</div>
{% endblock %}

{% block scripts %}
<script>
function conversationPage() {
    return {
        // æ•°æ®
        bookId: '{{ book_id }}',
        words: [],
        conversationId: null,
        messages: [],
        targetWords: [],
        recognizedText: '',
        currentRound: 0,
        totalRounds: 5,
        summary: {},

        // çŠ¶æ€
        isInitializing: true,
        initError: null,
        isLoading: false,
        isRecording: false,
        isRecognizing: false,
        isComplete: false,
        recorderReady: false,

        // å‘éŸ³çº æ­£ç›¸å…³
        showPronunciationFix: false,
        pronunciationIssue: {
            originalText: '',      // åŸå§‹è¯†åˆ«æ–‡æœ¬
            originalWord: '',      // è¢«è¯†åˆ«çš„è¯
            suggestedWord: '',     // å»ºè®®çš„è¯
            reason: ''             // åŸå› è¯´æ˜
        },
        pendingApiResponse: null,  // æš‚å­˜çš„ API å“åº”ï¼Œç­‰å¾…çº æ­£åç»§ç»­

        // å½•éŸ³ç›¸å…³
        recorder: null,
        recordingStartTime: null,
        recordingDuration: '0:00',
        recordingTimer: null,

        async init() {
            try {
                // æ£€æŸ¥å½•éŸ³æ”¯æŒ
                if (!AudioRecorder.isSupported()) {
                    this.initError = 'æ‚¨çš„æµè§ˆå™¨ä¸æ”¯æŒå½•éŸ³åŠŸèƒ½ï¼Œè¯·ä½¿ç”¨ Chrome æˆ– Safari';
                    this.isInitializing = false;
                    return;
                }

                // åˆå§‹åŒ–å½•éŸ³å™¨
                this.recorder = new AudioRecorder();
                const hasPermission = await this.recorder.requestPermission();
                if (!hasPermission) {
                    this.initError = 'è¯·å…è®¸ä½¿ç”¨éº¦å…‹é£ä»¥è¿›è¡Œè¯­éŸ³å¯¹è¯';
                    this.isInitializing = false;
                    return;
                }
                this.recorderReady = true;

                // ä» sessionStorage è·å–åˆšå­¦çš„å•è¯ï¼ˆå¸¦é”™è¯¯ä¿æŠ¤ï¼‰
                try {
                    const storedWords = sessionStorage.getItem('learnedWords');
                    if (storedWords) {
                        this.words = JSON.parse(storedWords);
                    }

                    // ä» sessionStorage è·å–å¯¹è¯è½®æ•°è®¾ç½®
                    const storedRounds = sessionStorage.getItem('conversationRounds');
                    if (storedRounds) {
                        this.totalRounds = parseInt(storedRounds) || 5;
                    }
                } catch (e) {
                    console.error('è¯»å– sessionStorage å¤±è´¥:', e);
                }

                if (this.words.length === 0) {
                    this.initError = 'æ²¡æœ‰æ‰¾åˆ°å·²å­¦ä¹ çš„å•è¯ï¼Œè¯·å…ˆå®Œæˆå•è¯å­¦ä¹ ';
                    this.isInitializing = false;
                    return;
                }

                // å¼€å§‹å¯¹è¯
                await this.startConversation();

            } catch (e) {
                console.error('åˆå§‹åŒ–å¤±è´¥:', e);
                this.initError = 'åˆå§‹åŒ–å¤±è´¥: ' + e.message;
            }

            this.isInitializing = false;
        },

        async startConversation() {
            this.isLoading = true;
            try {
                const response = await fetch('/api/conversation/start', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        words: this.words,
                        mode: 'guided',
                        rounds: this.totalRounds
                    })
                });

                if (!response.ok) {
                    throw new Error('API è¯·æ±‚å¤±è´¥');
                }

                const data = await response.json();

                if (data.error) {
                    throw new Error(data.error);
                }

                this.conversationId = data.conversation_id;
                this.targetWords = data.target_words || [];
                this.currentRound = 1;

                // æ·»åŠ  AI å¼€åœºç™½
                const greeting = data.greeting || 'ä½ å¥½ï¼è®©æˆ‘ä»¬å¼€å§‹ç»ƒä¹ å§ï¼';
                const question = data.question || 'How are you today?';

                this.messages.push({
                    role: 'ai',
                    content: greeting + '\n\n' + question,
                    chinese: data.question_chinese,
                    ttsText: question
                });

                // æ’­æ”¾ AI é—®é¢˜çš„è¯­éŸ³
                await this.playTTS(question);

            } catch (e) {
                console.error('å¼€å§‹å¯¹è¯å¤±è´¥:', e);
                this.initError = 'å¼€å§‹å¯¹è¯å¤±è´¥: ' + e.message;
            }
            this.isLoading = false;
        },

        async startRecording() {
            if (this.isLoading || this.isRecognizing || !this.recorderReady) return;

            try {
                await this.recorder.start();
                this.isRecording = true;
                this.recognizedText = '';

                // å¼€å§‹è®¡æ—¶
                this.recordingStartTime = Date.now();
                this.recordingDuration = '0:00';
                this.recordingTimer = setInterval(() => {
                    const elapsed = Math.floor((Date.now() - this.recordingStartTime) / 1000);
                    const mins = Math.floor(elapsed / 60);
                    const secs = elapsed % 60;
                    this.recordingDuration = `${mins}:${secs.toString().padStart(2, '0')}`;
                }, 100);

            } catch (e) {
                console.error('å½•éŸ³å¯åŠ¨å¤±è´¥:', e);
                alert('å½•éŸ³å¯åŠ¨å¤±è´¥ï¼Œè¯·æ£€æŸ¥éº¦å…‹é£æƒé™');
            }
        },

        async stopRecording() {
            if (!this.isRecording) return;

            // åœæ­¢è®¡æ—¶
            if (this.recordingTimer) {
                clearInterval(this.recordingTimer);
                this.recordingTimer = null;
            }

            try {
                const audioBlob = await this.recorder.stop();
                this.isRecording = false;

                // æ£€æŸ¥å½•éŸ³æ—¶é•¿ï¼ˆè‡³å°‘ 0.5 ç§’ï¼‰
                if (audioBlob.size < 1000) {
                    console.log('å½•éŸ³å¤ªçŸ­ï¼Œå¿½ç•¥');
                    return;
                }

                this.isRecognizing = true;
                this.scrollToBottom();

                // ä¸Šä¼ è¯†åˆ«
                const result = await this.recorder.uploadForRecognition(audioBlob);

                if (result.success && result.text) {
                    this.recognizedText = result.text;
                    // è‡ªåŠ¨æäº¤
                    await this.submitReply(result.text);
                } else {
                    const errorMsg = result.error || 'æœªèƒ½è¯†åˆ«è¯­éŸ³';
                    alert('è¯­éŸ³è¯†åˆ«å¤±è´¥: ' + errorMsg + '\nè¯·é‡è¯•');
                }

            } catch (e) {
                console.error('å½•éŸ³å¤„ç†å¤±è´¥:', e);
                alert('å½•éŸ³å¤„ç†å¤±è´¥ï¼Œè¯·é‡è¯•');
            } finally {
                this.isRecognizing = false;
            }
        },

        async submitReply(text, skipPronunciationCheck = false) {
            // æ·»åŠ ç”¨æˆ·æ¶ˆæ¯ï¼ˆå¦‚æœè¿˜æ²¡æ·»åŠ è¿‡ï¼‰
            if (!skipPronunciationCheck) {
                this.messages.push({ role: 'user', content: text });
                this.scrollToBottom();
            }

            this.isLoading = true;
            try {
                const response = await fetch('/api/conversation/reply', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        conversation_id: this.conversationId,
                        user_input: text,
                        target_words: this.targetWords
                    })
                });

                if (!response.ok) {
                    throw new Error('API è¯·æ±‚å¤±è´¥');
                }

                const data = await response.json();

                if (data.error) {
                    throw new Error(data.error);
                }

                // æ£€æŸ¥æ˜¯å¦æœ‰å‘éŸ³æ··æ·†é—®é¢˜ï¼ˆä¸”ä¸æ˜¯åœ¨çº æ­£åçš„é‡æ–°æäº¤ï¼‰
                const issue = data.pronunciation_issue;
                if (!skipPronunciationCheck && issue && issue.detected) {
                    // æš‚å­˜å“åº”ï¼Œå¼¹å‡ºçº æ­£å¯¹è¯æ¡†
                    this.pendingApiResponse = data;
                    this.pronunciationIssue = {
                        originalText: text,
                        originalWord: issue.original_word,
                        suggestedWord: issue.suggested_word,
                        reason: issue.reason || `è¯­éŸ³è¯†åˆ«å¯èƒ½å°† "${issue.suggested_word}" è¯†åˆ«æˆäº† "${issue.original_word}"`
                    };
                    this.showPronunciationFix = true;
                    this.isLoading = false;
                    return;  // ç­‰å¾…ç”¨æˆ·é€‰æ‹©
                }

                // æ­£å¸¸å¤„ç† AI å“åº”
                this.processApiResponse(data);

            } catch (e) {
                console.error('æäº¤å›å¤å¤±è´¥:', e);
                this.messages.push({
                    role: 'ai',
                    content: 'æŠ±æ­‰ï¼Œå‡ºç°äº†ä¸€äº›é—®é¢˜ã€‚è¯·å†è¯•ä¸€æ¬¡ã€‚',
                    chinese: ''
                });
            }

            this.isLoading = false;
            this.scrollToBottom();
        },

        // å¤„ç† API å“åº”ï¼ˆæå–å‡ºæ¥å¤ç”¨ï¼‰
        async processApiResponse(data) {
            // æ„å»º AI å›å¤
            let aiContent = data.feedback || '';
            let ttsText = '';

            // æ·»åŠ è¯­æ³•çº æ­£ï¼ˆå¦‚æœæœ‰ï¼‰
            if (data.correction) {
                aiContent += (aiContent ? '\n\n' : '') + 'ğŸ“ ' + data.correction;
            }

            // æ·»åŠ è€å¸ˆçš„è‹±æ–‡å›åº”
            const teacherResponse = data.response || data.next_question || '';
            if (teacherResponse) {
                aiContent += (aiContent ? '\n\n' : '') + teacherResponse;
                ttsText = teacherResponse;
            }

            this.messages.push({
                role: 'ai',
                content: aiContent || 'Good job!',
                chinese: data.response_chinese || data.next_question_chinese || '',
                ttsText: ttsText
            });

            this.targetWords = data.next_target_words || [];
            this.currentRound = data.round || this.currentRound + 1;
            this.totalRounds = data.total_rounds || 5;

            // æ’­æ”¾ AI å›å¤
            if (ttsText) {
                await this.playTTS(ttsText);
            }

            // æ£€æŸ¥æ˜¯å¦å®Œæˆ
            if (data.is_complete) {
                await this.loadSummary();
            }

            this.scrollToBottom();
        },

        // ä½¿ç”¨å»ºè®®çš„è¯ï¼ˆçº æ­£å‘éŸ³ï¼‰
        async useSuggestedWord() {
            this.showPronunciationFix = false;

            // æ›¿æ¢åŸæ–‡ä¸­çš„é”™è¯¯è¯
            const correctedText = this.pronunciationIssue.originalText.replace(
                new RegExp(this.pronunciationIssue.originalWord, 'gi'),
                this.pronunciationIssue.suggestedWord
            );

            // æ›´æ–°ç”¨æˆ·æ¶ˆæ¯æ˜¾ç¤º
            const lastUserMsgIndex = this.messages.findLastIndex(m => m.role === 'user');
            if (lastUserMsgIndex >= 0) {
                this.messages[lastUserMsgIndex].content = correctedText + ' âœ“';
            }

            // ç”¨çº æ­£åçš„æ–‡æœ¬é‡æ–°æäº¤
            this.pendingApiResponse = null;
            await this.submitReply(correctedText, true);
        },

        // ä¿æŒåŸæ ·ï¼ˆä¸çº æ­£ï¼‰
        async keepOriginalWord() {
            this.showPronunciationFix = false;

            // ç›´æ¥ä½¿ç”¨æš‚å­˜çš„å“åº”ç»§ç»­å¯¹è¯
            if (this.pendingApiResponse) {
                await this.processApiResponse(this.pendingApiResponse);
                this.pendingApiResponse = null;
            }
        },

        async playTTS(text) {
            if (!text) return;
            try {
                await TTS.playSentence(text);
            } catch (e) {
                console.error('TTS æ’­æ”¾å¤±è´¥:', e);
            }
        },

        async loadSummary() {
            try {
                const response = await fetch(`/api/conversation/summary/${this.conversationId}`);
                if (response.ok) {
                    this.summary = await response.json();
                }
                this.isComplete = true;
            } catch (e) {
                console.error('è·å–æ€»ç»“å¤±è´¥:', e);
                this.isComplete = true;
                this.summary = {
                    words_practiced: this.words.map(w => w.word),
                    words_used_correctly: [],
                    overall_feedback: 'å¯¹è¯å·²å®Œæˆï¼',
                    score: 0
                };
            }
        },

        scrollToBottom() {
            this.$nextTick(() => {
                if (this.$refs.chatContainer) {
                    this.$refs.chatContainer.scrollTop = this.$refs.chatContainer.scrollHeight;
                }
            });
        },

        goBack() {
            // æ¸…ç†å½•éŸ³å™¨
            if (this.recorder) {
                this.recorder.cancel();
            }
            if (this.recordingTimer) {
                clearInterval(this.recordingTimer);
            }

            // æ¸…ç† sessionStorage
            sessionStorage.removeItem('learnedWords');

            // è¿”å›é¦–é¡µ
            window.location.href = '/';
        }
    }
}
</script>
{% endblock %}
